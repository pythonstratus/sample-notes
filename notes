# Databricks notebook source
from pyspark.sql.functions import *
from pyspark.sql.types import *
import xml.etree.ElementTree as ET

# COMMAND ----------
# Define the schema based on the mappings
contract_schema = StructType([
    StructField("piid", StringType(), True),
    StructField("agency_id", StringType(), True),
    StructField("agency_name", StringType(), True),
    StructField("mod_number", StringType(), True),
    StructField("transaction_number", StringType(), True),
    StructField("solicitation_id", StringType(), True),
    StructField("signed_date", TimestampType(), True),
    StructField("effective_date", TimestampType(), True),
    StructField("current_completion_date", TimestampType(), True),
    StructField("ultimate_completion_date", TimestampType(), True),
    StructField("last_date_to_order", StringType(), True),
    StructField("base_and_all_options_value", DecimalType(18,2), True),
    StructField("base_and_exercised_options_value", DecimalType(18,2), True),
    StructField("obligated_amount", DecimalType(18,2), True),
    StructField("total_base_and_all_options_value", DecimalType(18,2), True),
    StructField("total_base_and_exercised_options_value", DecimalType(18,2), True),
    StructField("total_obligated_amount", DecimalType(18,2), True),
    StructField("contracting_office_agency_id", StringType(), True),
    StructField("funding_requesting_agency_id", StringType(), True),
    StructField("foreign_funding", StringType(), True),
    StructField("type_of_contract_pricing", StringType(), True),
    StructField("multi_year_contract", StringType(), True),
    StructField("type_of_idc", StringType(), True),
    StructField("multiple_or_single_award_idc", StringType(), True),
    StructField("cost_or_pricing_data", StringType(), True),
    StructField("description_of_contract_requirement", StringType(), True),
    StructField("purchase_card_as_payment_method", StringType(), True),
    StructField("vendor_name", StringType(), True),
    StructField("vendor_doing_as_business_name", StringType(), True),
    StructField("street_address", StringType(), True),
    StructField("city", StringType(), True),
    StructField("state", StringType(), True),
    StructField("zip_code", StringType(), True),
    StructField("country_code", StringType(), True),
    StructField("phone_no", StringType(), True),
    StructField("congressional_district_code", StringType(), True)
])

# COMMAND ----------
# Function to parse XML and extract data
def parse_fpds_xml(xml_content):
    root = ET.fromstring(xml_content)
    # Define namespace mapping
    ns = {
        'ns0': 'http://www.w3.org/2005/Atom',
        'ns1': 'https://www.fpds.gov/FPDS'
    }
    
    contract_data = []
    
    # Parse each entry
    for entry in root.findall('.//ns1:award', ns):
        contract = {}
        
        # Extract contract ID information
        contract['piid'] = entry.find('.//ns1:PIID', ns).text if entry.find('.//ns1:PIID', ns) is not None else None
        contract['agency_id'] = entry.find('.//ns1:agencyID', ns).text if entry.find('.//ns1:agencyID', ns) is not None else None
        contract['agency_name'] = entry.find('.//ns1:agencyID', ns).get('name') if entry.find('.//ns1:agencyID', ns) is not None else None
        
        # Extract dates
        contract['signed_date'] = entry.find('.//ns1:signedDate', ns).text if entry.find('.//ns1:signedDate', ns) is not None else None
        contract['effective_date'] = entry.find('.//ns1:effectiveDate', ns).text if entry.find('.//ns1:effectiveDate', ns) is not None else None
        
        # Extract dollar values
        contract['obligated_amount'] = entry.find('.//ns1:obligatedAmount', ns).text if entry.find('.//ns1:obligatedAmount', ns) is not None else None
        contract['base_and_exercised_options_value'] = entry.find('.//ns1:baseAndExercisedOptionsValue', ns).text if entry.find('.//ns1:baseAndExercisedOptionsValue', ns) is not None else None
        
        # Extract vendor information
        vendor = entry.find('.//ns1:vendor', ns)
        if vendor is not None:
            contract['vendor_name'] = vendor.find('.//ns1:vendorName', ns).text if vendor.find('.//ns1:vendorName', ns) is not None else None
            
            vendor_location = vendor.find('.//ns1:vendorLocation', ns)
            if vendor_location is not None:
                contract['street_address'] = vendor_location.find('.//ns1:streetAddress', ns).text if vendor_location.find('.//ns1:streetAddress', ns) is not None else None
                contract['city'] = vendor_location.find('.//ns1:city', ns).text if vendor_location.find('.//ns1:city', ns) is not None else None
                contract['state'] = vendor_location.find('.//ns1:state', ns).text if vendor_location.find('.//ns1:state', ns) is not None else None
                contract['zip_code'] = vendor_location.find('.//ns1:ZIPCode', ns).text if vendor_location.find('.//ns1:ZIPCode', ns) is not None else None
                
        contract_data.append(contract)
    
    return contract_data

# COMMAND ----------
# Read XML file from DBFS
xml_path = "/path/to/your/fpds.xml"  # Update with actual path
xml_content = spark.sparkContext.wholeTextFiles(xml_path).values().collect()[0]

# Parse XML
contract_data = parse_fpds_xml(xml_content)

# Create DataFrame
contract_df = spark.createDataFrame(contract_data, schema=contract_schema)

# Clean up the data
contract_df = contract_df.withColumn("signed_date", to_timestamp("signed_date")) \
    .withColumn("effective_date", to_timestamp("effective_date")) \
    .withColumn("obligated_amount", col("obligated_amount").cast(DecimalType(18,2))) \
    .withColumn("base_and_exercised_options_value", col("base_and_exercised_options_value").cast(DecimalType(18,2)))

# COMMAND ----------
# Display the results
display(contract_df)

# COMMAND ----------
# Save the data if needed
contract_df.write.mode("overwrite").parquet("/path/to/output/contracts.parquet")
