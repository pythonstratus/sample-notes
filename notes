def generate_report(analysis_results: Dict, include_score_explanation: bool = True) -> str:
    """
    Generates a detailed markdown report from the analysis results.
    """
    report = []
    
    # Add report header
    report.append("# Database Key Analysis Report\n")
    
    # Add scoring explanation if requested
    if include_score_explanation:
        report.append("## Confidence Score Explanation")
        report.append("The confidence score (0-100%) is calculated based on the following criteria:")
        report.append("1. Uniqueness (40%): Column has unique constraint")
        report.append("2. NOT NULL constraint (20%): Column doesn't allow nulls")
        report.append("3. Data Type (10%): Column is INTEGER, BIGINT, or UUID")
        report.append("4. Null Fraction (10%): No null values in actual data")
        report.append("5. Distinct Values (10%): >99% values are unique")
        report.append("6. Existing Constraints (10%): Column has other constraints\n")
        report.append("Scores above 70% indicate good candidates for primary keys.\n")
    
    # Potential Primary Keys
    report.append("## Potential Primary Keys")
    
    if not analysis_results['potential_pks'].empty:
        for _, row in analysis_results['potential_pks'].iterrows():
            report.append(f"\n### Table: {row['table_name']}")
            report.append(f"- Column: {row['column_name']}")
            report.append(f"- Confidence Score: {row['pk_score']:.2%}")
            report.append(f"- Data Type: {row['data_type']}")
            report.append(f"- Current Index: {row['index_name']}")
            if row['recommendations']:
                report.append("- Recommendations:")
                for rec in row['recommendations']:
                    report.append(f"  * {rec}")
    else:
        report.append("\nNo potential primary keys identified.")
    
    # Potential Foreign Keys
    report.append("\n## Potential Foreign Keys")
    
    if not analysis_results['potential_fks'].empty:
        for _, row in analysis_results['potential_fks'].iterrows():
            report.append(f"\n### {row['source_table']}.{row['source_column']}")
            report.append(f"- Confidence Score: {row['fk_score']:.2%}")
            report.append(f"- Data Type: {row['data_type']}")
            report.append(f"- Could reference: {', '.join(row['potential_referenced_tables'])}")
            if row['recommendations']:
                report.append("- Recommendations:")
                for rec in row['recommendations']:
                    report.append(f"  * {rec}")
    else:
        report.append("\nNo potential foreign keys identified.")
    
    return "\n".join(report)

def save_report_to_file(report: str, filename: str) -> None:
    """
    Saves the report to a text file.
    """
    with open(filename, 'w', encoding='utf-8') as f:
        f.write(report)

# Usage example
if __name__ == "__main__":
    results = analyze_indexes(
        host="localhost",
        database="your_database",
        user="your_user",
        password="your_password",
        port=5432,
        schema="your_schema"
    )
    
    # Generate report with score explanation
    report = generate_report(results, include_score_explanation=True)
    
    # Save to file
    output_file = f"db_key_analysis_{results['schema']}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
    save_report_to_file(report, output_file)
    print(f"Report has been saved to: {output_file}")
    
    # Also print to console if desired
    print(report)


---------------------------------
Here's a draft email explaining the index-based approach to identifying potential keys:

Subject: Database Key Analysis Report - Using Indexes to Identify Potential PK/FK Relationships

Hi Team,

I wanted to share our approach to identifying potential primary and foreign key candidates in our database using index analysis. We've developed a report that analyzes existing indexes to suggest possible key relationships.

Why Focus on Indexes:
- Indexes often indicate important columns that are frequently queried or joined
- Unique indexes are natural candidates for primary keys
- Indexed columns that share names and data types across tables often suggest potential foreign key relationships
- Existing indexes provide performance benefits if converted to PK/FK constraints

The generated report provides:
1. A list of potential primary key candidates with confidence scores based on:
   - Index uniqueness
   - NULL constraints
   - Data type suitability
   - Actual data distribution

2. Potential foreign key relationships based on:
   - Matching column names
   - Compatible data types
   - Existing index patterns

Each suggestion includes specific recommendations for implementing the constraints and any necessary data cleanup steps.

Would you like me to schedule a brief review of the findings?

Best regards,
[Your name]
